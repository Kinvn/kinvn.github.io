---
layout: article
title: AQS 源码解析
key: AQS-2021-06-26
sharing: true
show_author_profile: true
footer: false
show_edit_on_github: false
show_subscribe: false
---

最近在看`LinkedBlockingQueue`源码的时候发现内部是采用`ReentrantLock`进行线程同步的，众所周知 Java 中线程同步的方法除了最常用的`synchronized`关键字和`Object#wait`等方法，还有另一种方式那就是使用`ReentrantLock`类。


`ReentrantLock`本身只是实现了`Lock`接口，而真正实现线程同步的关键是另外一个类`AbstractQueuedSynchronizer`(AQS)，`AQS`是 Java 中一个线程同步框架，基于`AQS`重写`tryAcquire()`和`tryRelease()`等方法就可以实现线程同步，因此本文就从`ReetrantLock`为例子，解析`AQS`的工作流程。

<!--more-->

# Tips

- 全文会用`AQS`指代`AbstractQueuedSynchronizer`
- 为了提升阅读流畅性，文中会在需要的地方将代码二次贴出，并加上`repeat`标识

# 源码梳理

## 加锁

### ReentrantLock#lock

首先，从`ReentrantLock#lock`方法入手。

```java
    public void lock() {
        sync.lock();
    }
```

调用的是`ReentrantLock$Sync#lock`方法，根据创建`ReentrantLock`时的参数可为`NonfairSync#lock`或`FairSync#lock`，分别代表非公平锁和公平锁实现，它们之间的具体类图关系如下：

//todo add img

为了更好地理解，本文以`ReentrantLock`默认构造函数所用的`NonfairSync`为例，至于`FairSync`公平锁在实现逻辑上基本相同。

### NonfairSync#lock

```java
    final void lock() {
        if (compareAndSetState(0, 1)) //CAS 尝试设置 state 为 1，0 表示没有线程持有锁
            setExclusiveOwnerThread(Thread.currentThread()); //成功，设置当前线程为占有线程，lock 流程结束
        else
            acquire(1); //失败，执行 AQS#acquire 方法
    }
```

### AQS#acquire

```java
    public final void acquire(int arg) {
        if (!tryAcquire(arg) && //实际相当于调用 Sync#nonfairTryAcquire
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

首先调用`tryAcquire(int)`，注意此方法在`AQS`中为空实现，具体实现在`NonfairSync`中，实际内部调用`Sync#nonfairTryAcquire`

### Sync#nonfairTryAcquire

```java
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState(); //获取 AQS 的 state
        if (c == 0) { //等于0，表示没有线程持有锁
            if (compareAndSetState(0, acquires)) { //CAS，成功表示获取锁，acquires 通常为 1
                setExclusiveOwnerThread(current); //设置占有线程，lock 流程结束
                return true;
            }
        }
        // Mark A
        else if (current == getExclusiveOwnerThread()) { //如果当前线程就是占有锁的线程 
            int nextc = c + acquires; //state += acquires
            if (nextc < 0) //超过 Integer.MAX_VALUE，溢出为负数
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false; //acquire 失败
    }
```

从上面的`Mark A`代码块可以看出`ReentrantLock`的可重入性，每调用一次`lock`意味着`state += 1`，调用`unlock`则`state -= 1`，因此完全释放锁需要调用相同次数的`unlock()`，当 state 为 0 时表明锁被释放。

如果`tryAcquire`失败的话，紧接着调用`addWaiter`方法，`addWaiter`会生成一个`AQS$Node`，这个`Node`实际是对当前线程的一个封装。

### AQS#addWaiter

```java
    //repeat start
    public final void acquire(int arg) {
        if (!tryAcquire(arg) && 
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //acquire 失败，先调用 addWaiter
            selfInterrupt();
    }
    //repeat end

    //AQS#addWaiter
    private Node addWaiter(Node mode) { //mode = Node.EXCLUSIVE
        Node node = new Node(Thread.currentThread(), mode); //将线程封装成 Node 
        Node pred = tail; //获取尾节点
        if (pred != null) { //尾节点不为空，表明队列不为空
            node.prev = pred;
            // Mark A
            if (compareAndSetTail(pred, node)) { //CAS 尝试将当前 Node 替换成尾节点
                pred.next = node; //成功替换为尾节点，将上一个尾节点的 next 指向当前 Node
                return node; //返回 Node
            }
        }
        enq(node); //失败，说明有其他线程替换了尾节点，调用 enq
        return node;
    }

    //AQS#enq
    private Node enq(final Node node) {
        for (;;) { //开始循环
            Node t = tail;
            if (t == null) { //尾节点为空 = 队列为空，需要初始化一个节点，该节点不代表任何线程，是一个 dummy 节点
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else { //同上 Mark A 处代码相同，将当前 Node 设置到尾节点，失败则进入下一个循环，直至成功
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
```

通过上面的代码可以了解到，`AbstractQueuedSynchronizer`的`Queued`指的是在该类中维护了一个`Node`的双向链表结构的 FIFO 队列，这个队列中如果有 n 个线程，那么就会有 n + 1 个 Node，因为头节点是个虚`Node`。

`addWaiter`之后会将当前`Node`返回给`acquireQueued`，这同时意味着我们的线程已经在队列尾部了。

### AQS#acquireQueued

```java
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false; //中断标记
            for (;;) { //开始循环
                final Node p = node.predecessor(); //获取前一个 Node
                if (p == head && tryAcquire(arg)) { //判断前一个节点是不是 head，是的话 CAS 尝试获取锁，head 是 dummy Node，等于说我们是队列里第一个等待执行的线程
                    setHead(node); //成功获取锁，将当前 Node 设置为 head，注意此时我们的 Node 替换了原来的 dummy head
                    p.next = null; //释放前节点的引用，帮助 GC
                    failed = false;
                    return interrupted; // == false
                }
                if (shouldParkAfterFailedAcquire(p, node) && //tryAcquire失败，检查是否需要 park 线程(Go A ↓↓↓↓↓↓)
                    parkAndCheckInterrupt()) //执行 park，并检查中断 (Go B ↓↓↓↓↓↓)
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    // A
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            //前一个节点已经 SIGNAL 了，意味着当前节点可以直接 park
            // SIGNAL = -1, CONDITION = -2, PROPAGATE = -3, CANCELLED = 1
            return true;
        if (ws > 0) { //前一个节点已经取消
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0); //循环向前寻找节点直到不为 CANCELLED 的节点
            pred.next = node; //弃置中间的 CANCELLED 节点
        } else {
            //前一个节点要么为 0 要么为 PROPAGATE，CAS 尝试将其设置为 SIGNAL
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }

    // B
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this); //执行到这里表明线程阻塞，停止自旋获取锁，等待 unpark
        return Thread.interrupted();//unpark 恢复执行后检查是否有中断
    }
```
到`LockSupport#park`为止，整个`ReentrantLock#lock`方法的流程梳理完毕。

### **小结**

1. `Reentrant#lock`实际就是执行`NonfairSync#lock`，在这一步线程会直接尝试 CAS 争抢锁，失败的话才进行第二步。
2. 这一步执行`AQS#acquire`实际执行`Sync#nonfairTryAcquire`，和第一步一样先尝试 CAS 争抢锁，同时这一步最关键的是处理重入锁，等于说所有重入的线程在第一步都会失败，然后在这里成功。
3. `AQS#addWaiter`的主要工作就是把线程封装成`Node`节点，并插入到队列的尾端。
4. 在`Node`入列后，这一步的工作就是等待出列，先循环判断`Node`是不是队列里第一个等待执行的线程，是的话尝试 CAS 争抢锁，这个行为称为锁的自旋；锁自旋一定次数后，判断条件为`Node`的前一个节点的状态如果变成`SIGNAL`，那么停止自旋，线程`park`阻塞，等待唤醒。

从总结中可以看出，每个线程在入列之前，都会在 1、2 步先尝试 CAS 争抢锁，这里体现了非公平锁的特点，不重点关注加锁的先后顺序，提升了吞吐量。

